let web3,accounts;async function getContract(e){let t=window[e+"Abi"],n=window.config[e+"Address"];return window.cachedContracts[e]||(window.cachedContracts[e]=new ethers.Contract(n,t,provider.getSigner())),window.cachedContracts[e]}function getCoinbase(){return ethereum.request({method:"eth_accounts"})}async function metaMaskSigning(e,t,n,a,i){let s={name:"FEAR",version:"1.0",chainId:e,verifyingContract:t};const r=n+" "+getTimestamp(),o=JSON.stringify({types:{EIP712Domain:[{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"}],MetaTransaction:[{name:"message",type:"string"}]},domain:s,primaryType:"MetaTransaction",message:{message:r}});await web3.currentProvider.sendAsync({method:"eth_signTypedData_v4",params:[accounts[0],o],from:accounts[0]},async function(e,t){if(e)return void await i(e);let n=window.sigUtil.recoverTypedSignature_v4({data:JSON.parse(o),sig:t.result});n&&n.toUpperCase()===accounts[0].toUpperCase()?await a({signature:t.result,message:r,address:n}):await i("Signature is not valid.")})}window.cachedContracts={};